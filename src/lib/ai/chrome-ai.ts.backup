/**
 * Chrome Built-in AI Service
 * Wrapper for Chrome AI APIs with error handling and availability checks
 */

import { ErrorType, ExtensionError, type ChromeAICapabilities } from '@/types'
import { logger } from '@/utils/logger'
import { retry } from '@/utils/helpers'

export class ChromeAIService {
  private capabilities: ChromeAICapabilities = {
    summarizer: false,
    embedder: false,
    writer: false,
    translator: false,
    proofreader: false,
    rewriter: false,
  }

  /**
   * Initialize and check AI capabilities
   */
  async initialize(): Promise<ChromeAICapabilities> {
    logger.info('Initializing Chrome AI services...')

    try {
      // Check if AI APIs are available (they might not be in all contexts)
      const aiGlobal = (self as any).ai
      const translationGlobal = (self as any).translation

      // Check Prompt API (for embeddings) - Extensions only
      if (aiGlobal?.languageModel) {
        try {
          const caps = await aiGlobal.languageModel.capabilities()
          this.capabilities.embedder = caps.available === 'readily' || caps.available === 'after-download'
          logger.info('Prompt API available:', this.capabilities.embedder)
        } catch (e) {
          logger.warn('Prompt API not available:', e)
          this.capabilities.embedder = false
        }
      }

      // Check Summarizer API (stable)
      if (aiGlobal?.summarizer) {
        try {
          const caps = await aiGlobal.summarizer.capabilities()
          this.capabilities.summarizer = caps.available === 'readily' || caps.available === 'after-download'
          logger.info('Summarizer API available:', this.capabilities.summarizer)
        } catch (e) {
          logger.warn('Summarizer API not available:', e)
          this.capabilities.summarizer = false
        }
      }

      // Check Writer API (origin trial)
      if (aiGlobal?.writer) {
        try {
          const caps = await aiGlobal.writer.capabilities()
          this.capabilities.writer = caps.available === 'readily' || caps.available === 'after-download'
          logger.info('Writer API available:', this.capabilities.writer)
        } catch (e) {
          logger.warn('Writer API not available:', e)
          this.capabilities.writer = false
        }
      }

      // Check Rewriter API (origin trial)
      if (aiGlobal?.rewriter) {
        try {
          const caps = await aiGlobal.rewriter.capabilities()
          this.capabilities.rewriter = caps.available === 'readily' || caps.available === 'after-download'
          logger.info('Rewriter API available:', this.capabilities.rewriter)
        } catch (e) {
          logger.warn('Rewriter API not available:', e)
          this.capabilities.rewriter = false
        }
      }

      // Check Proofreader API (origin trial)
      if (aiGlobal?.proofreader) {
        try {
          const caps = await aiGlobal.proofreader.capabilities()
          this.capabilities.proofreader = caps.available === 'readily' || caps.available === 'after-download'
          logger.info('Proofreader API available:', this.capabilities.proofreader)
        } catch (e) {
          logger.warn('Proofreader API not available:', e)
          this.capabilities.proofreader = false
        }
      }

      // Check Translation API (stable)
      if (translationGlobal?.canTranslate) {
        try {
          // Translation API is available if the global exists
          this.capabilities.translator = true
          logger.info('Translation API available:', this.capabilities.translator)
        } catch (e) {
          logger.warn('Translation API not available:', e)
          this.capabilities.translator = false
        }
      }

      logger.info('AI capabilities:', this.capabilities)
      return this.capabilities
    } catch (error) {
      logger.error('Failed to initialize AI services:', error)
      // Don't throw - allow extension to work without AI if needed
      logger.warn('Extension will run with limited AI capabilities')
      return this.capabilities
    }
  }

  /**
   * Generate summary from text
   */
  async summarize(text: string, maxLength: number = 500): Promise<string> {
    if (!this.capabilities.summarizer) {
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Summarizer API is not available'
      )
    }

    try {
      logger.debug('Generating summary...')
      const aiGlobal = (self as any).ai
      const summarizer = await aiGlobal.summarizer.create()
      const summary = await retry(
        () => summarizer.summarize(text),
        { maxAttempts: 3, delay: 500 }
      )
      logger.debug('Summary generated successfully')
      return summary
    } catch (error) {
      logger.error('Failed to generate summary:', error)
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Failed to generate summary',
        error
      )
    }
  }

  /**
   * Generate embedding vector from text
   */
  async embed(text: string): Promise<Float32Array> {
    if (!this.capabilities.embedder) {
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Embedding API is not available'
      )
    }

    try {
      logger.debug('Generating embedding...')
      const aiGlobal = (self as any).ai
      const session = await aiGlobal.languageModel.create()
      const response = await retry(
        () => session.prompt(`Generate embedding for: ${text}`),
        { maxAttempts: 3, delay: 500 }
      )
      // For now, create a simple hash-based embedding as fallback
      // TODO: Use proper embedding API when available
      const embedding = new Float32Array(384)
      for (let i = 0; i < text.length && i < 384; i++) {
        embedding[i] = text.charCodeAt(i) / 255
      }
      logger.debug('Embedding generated successfully')
      return embedding
    } catch (error) {
      logger.error('Failed to generate embedding:', error)
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Failed to generate embedding',
        error
      )
    }
  }

  /**
   * Generate text using writer API
   */
  async write(
    prompt: string,
    options?: { tone?: string; length?: string }
  ): Promise<string> {
    if (!this.capabilities.writer) {
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Writer API is not available'
      )
    }

    try {
      logger.debug('Generating text...')
      const text = await retry(
        () => chrome.ai.writer.write(prompt, options),
        { maxAttempts: 3, delay: 500 }
      )
      logger.debug('Text generated successfully')
      return text
    } catch (error) {
      logger.error('Failed to generate text:', error)
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Failed to generate text',
        error
      )
    }
  }

  /**
   * Translate text
   */
  async translate(
    text: string,
    targetLanguage: string,
    sourceLanguage?: string
  ): Promise<string> {
    if (!this.capabilities.translator) {
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Translator API is not available'
      )
    }

    try {
      logger.debug(`Translating to ${targetLanguage}...`)
      const translated = await retry(
        () => chrome.ai.translator.translate(text, { sourceLanguage, targetLanguage }),
        { maxAttempts: 3, delay: 500 }
      )
      logger.debug('Translation completed')
      return translated
    } catch (error) {
      logger.error('Failed to translate:', error)
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Failed to translate text',
        error
      )
    }
  }

  /**
   * Proofread text
   */
  async proofread(text: string): Promise<string> {
    if (!this.capabilities.proofreader) {
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Proofreader API is not available'
      )
    }

    try {
      logger.debug('Proofreading text...')
      const proofread = await retry(
        () => chrome.ai.proofreader.proofread(text),
        { maxAttempts: 3, delay: 500 }
      )
      logger.debug('Proofreading completed')
      return proofread
    } catch (error) {
      logger.error('Failed to proofread:', error)
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Failed to proofread text',
        error
      )
    }
  }

  /**
   * Rewrite text with different tone/length/format
   */
  async rewrite(
    text: string,
    options?: { tone?: string; length?: string; format?: string }
  ): Promise<string> {
    if (!this.capabilities.rewriter) {
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Rewriter API is not available'
      )
    }

    try {
      logger.debug('Rewriting text with options:', options)
      const rewritten = await retry(
        () => chrome.ai.rewriter.rewrite(text, options),
        { maxAttempts: 3, delay: 500 }
      )
      logger.debug('Rewriting completed')
      return rewritten
    } catch (error) {
      logger.error('Failed to rewrite:', error)
      throw new ExtensionError(
        ErrorType.AI_API_NOT_AVAILABLE,
        'Failed to rewrite text',
        error
      )
    }
  }

  /**
   * Get current capabilities
   */
  getCapabilities(): ChromeAICapabilities {
    return { ...this.capabilities }
  }
}

// Export singleton instance
export const chromeAI = new ChromeAIService()
